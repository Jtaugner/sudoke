const NUMBER_OF_LEAVES = 36;


function init()
{
    var container = document.getElementById('leafContainer');
    for (var i = 0; i < NUMBER_OF_LEAVES / 9; i++)
    {
        for(let i = 1; i < 10; i++){
            container.appendChild(createALeaf(i));
        }

    }
}


function randomInteger(low, high)
{
    return low + Math.floor(Math.random() * (high - low));
}


function randomFloat(low, high)
{
    return low + Math.random() * (high - low);
}


function pixelValue(value)
{
    return value + 'px';
}

function durationValue(value)
{
    return value + 's';
}

function createALeaf(n)
{

    var leafDiv = document.createElement('div');
    leafDiv.innerText = n;

    leafDiv.style.top = "-35px";

    leafDiv.style.left = pixelValue(randomInteger(0, document.querySelector(".game").clientWidth));



    leafDiv.style.webkitAnimationName = 'fade, drop';



    var fadeAndDropDuration = durationValue(randomFloat(4, 9));



    leafDiv.style.webkitAnimationDuration = fadeAndDropDuration + ', ' + fadeAndDropDuration;

    var leafDelay = durationValue(randomFloat(0, 3.5));
    leafDiv.style.webkitAnimationDelay = leafDelay + ', ' + leafDelay;




    return leafDiv;
}
function params(data) {
    try{
        ym(54537937, 'params', data);
    }catch(ignored){}
}

window.addEventListener('load', init, false);

let advTime = true;
let showAdv;
if(window.YaGames){
    YaGames.init({
        adv: {
            onAdvClose: wasShown => {
                if(!wasShown) advTime = true;
            }
        }
    }).then(ysdk => {
        showAdv = () => {
            ysdk.adv.showFullscreenAdv({
                callbacks: {
                    onClose: function() {
                        advTime = false;
                        setTimeout(()=>{
                            advTime = true;
                        }, 180000);
                    }
                }
            });
        };
    });
}
let interval;
const game = new Vue({
    el: '.game',
    data: {
        menu: true,
        isPhone: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
        sudokuRight: [],
        sudoku: [],
        mySudoku: [],
        content: false,
        levels: false,
        lvl: 4,
        checkedCell: [-1,-1],
        selectedNum: -1,
        time: 0,
        timer: "00:00:00",
        result: 0,
        showResult: false,
        blackout: false,
        solved: false,
        size: 3,
        sizeShow: false,
        rules: false
    },
    computed: {
    },
    components: {

    },
    methods: {
        startGame(){
            clearInterval(interval);
            this.levels = false;
            this.selectedNum = -1;
            this.content = true;
            this.showResult = false;
            this.blackout = false;
            this.sizeShow = false;
            this.solved = false;
            this.menu = false;
            this.getSudoku();
            this.solved = false;
            this.time = 0;
            this.timer = "00:00:00";
            interval = setInterval(()=>{
                this.time++;
                this.getTime();
            }, 1000)
        },
        getTime(){
            let time = this.time;
            let h = Math.floor(time / 3600);
            time %= 3600;
            let m = Math.floor(time / 60);
            time %= 60;
            this.timer = addNull(h) + ":"+ addNull(m) + ":" + addNull(time);
        },
        getSudoku(){
            this.sudokuRight = createSudoku(this.size).slice(0);
            let sudoku = [...this.sudokuRight.map( (e)=>e.slice(0))];
            let lvls = {"2": [4,6,8,10,12], "3": [27, 35, 43, 50, 58]};
            let n = lvls[this.size][this.lvl];
            let size2 = this.size * this.size;
            let rows = Math.floor(n / size2);
            let freeN = n - rows * size2;
            let usedCols = [];
            for(let i = 0; i < size2; i++) usedCols.push(0);
            for(let q = 0; q < size2; q++){
                for(let i = 0; i < rows; i++){
                    let rand;
                    try{
                        rand = getRandInRow(usedCols, sudoku[q], size2);
                    }catch(e){
                        usedCols = [];
                        for(let i = 0; i < size2; i++) usedCols.push(0);
                        sudoku = [...this.sudokuRight.map( (e)=>e.slice(0))];
                        rand = getRandInRow(usedCols, sudoku[q], size2);
                        q = 0;
                        i = 0;
                    }
                    usedCols[rand]++;
                    sudoku[q][rand] = 0;
                }
            }
            for(let i = 0; i < freeN; i++){
                let ab = getRandFree(sudoku, usedCols, size2);
                usedCols[ab[1]]++;
                sudoku[ab[0]][ab[1]] = 0;
            }
            let nulls = 0;
            for(let i = 0; i < size2; i++){
                for(let q = 0; q < size2; q++){
                    if(sudoku[i][q] === 0) nulls++;
                }
            }
            this.sudoku = [...sudoku.map((e) => e.slice(0))];
            this.mySudoku = [...sudoku.map((e) => e.map((e) => e === 0 ? [] : e).slice(0))];
            this.checkedCell = [-1, -1];
        },
        checkCell(i, q){
            if(this.sudoku[i][q] !== 0){
                this.checkedCell = [-1, -1];
                this.selectedNum = this.sudoku[i][q];
                return;
            }
            this.selectedNum = -1;
            this.checkedCell = [i, q];
        },
        addCompCell(event){
            if(this.size === 2 && (Number(event.key) >= 1)&&(Number(event.key)<=4)){
                this.addNum(Number(event.key));
            }
            if (this.size === 3 && (Number(event.key) >= 1)&&(Number(event.key)<=9)){
                this.addNum(Number(event.key));
            }
            else if(event.key === 'Delete' || event.key === 'Backspace' || event.key === ' '){
                this.addNum('');
            }
        },
        addNum(n){
            if(this.checkedCell[0] === -1) return;
            if(n === ''){
                this.mySudoku[this.checkedCell[0]][this.checkedCell[1]].splice(0, this.mySudoku[this.checkedCell[0]][this.checkedCell[1]].length);
                return;
            }
            if(this.mySudoku[this.checkedCell[0]][this.checkedCell[1]].includes(n)){
                let index = this.mySudoku[this.checkedCell[0]][this.checkedCell[1]].indexOf(n);
                this.mySudoku[this.checkedCell[0]][this.checkedCell[1]].splice(index, 1);
                return;
            }
            this.mySudoku[this.checkedCell[0]][this.checkedCell[1]].push(n);
        },
        returnMenu(){
            if(window.YaGames && advTime){
                showAdv();
            }
            clearInterval(interval);
            this.menu = true;
            this.levels = false;
            this.sizeShow = false;
            this.content = false;
            this.blackout = false;
            this.timer = "00:00:00";
        },
        showLvl(){
            this.menu = false;
            this.levels = true;
            this.sizeShow = false;
        },
        showSizes(){
            if(window.YaGames && advTime){
                showAdv();
            }
            this.menu = false;
            this.sizeShow = true;
        },
        setLvl(lvl){
            this.lvl = lvl;
            this.startGame();
        },
        setSize(size){
            this.size = size;
            this.showLvl();
        },
        testSudoku(){
            if(this.solved) return;
            let bool = isSudokuRight(this.mySudoku, this.sudokuRight);
            this.showResult = true;
            this.blackout = true;
            if(bool){
                this.result = 1;
                clearInterval(interval);
            }else{
                this.result = 0;
            }
        },
        getLvlName() {
            let names = ["Новичок", "Лёгкий", "Средний", "Тяжёлый", "Эксперт"];
            return names[this.lvl];
        },
        continueGame(){
            this.showResult = false;
            this.blackout = false;
            if(window.YaGames && advTime){
                showAdv();
            }
        },
        cleanBlackout(){
            this.showResult = false;
            this.blackout = false;
        },
        solveSudoku(){
            if(window.YaGames && advTime){
                showAdv();
            }
            this.result = -1;
            this.blackout = true;
            this.showResult = true;
        },
        solveSudokuExactly() {
            this.showResult = false;
            this.blackout = false;
            this.solved = true;
            clearInterval(interval);
            this.sudoku = this.sudokuRight;
        },
        toggleRules(){
            this.rules = !this.rules;
        }

    },
    mounted: function() {
        this.$nextTick(function() {
            document.querySelector(".start").remove()
        })
    }
});
function getRandInRow(row, sudoku, size) {
    let nulls = [];
    for(let i = 0; i < size; i++){
        if(row[i] === 0) nulls.push(i);
    }
    if(nulls.length === 0){
        let rand = Math.floor(Math.random() * size);
        if(sudoku[rand] === 0 || row[rand] === size-1) return getRandInRow(row, sudoku, size);
        return rand;
    }else{
        let rand = Math.floor(Math.random() * nulls.length);
        return nulls[rand];
    }
}
function getRandFree(sudoku, usedColls, size) {
    let rand1 = Math.floor(Math.random() * size);
    let rand2 = Math.floor(Math.random() * size);
    if(usedColls[rand2] === size-1 || sudoku[rand1][rand2] === 0) return getRandFree(sudoku, usedColls, size);
    return [rand1, rand2];
}

function isSudokuRight(arr) {
    let a = [];
    for(let i = 0; i < arr.length; i++){
        a.push([]);
        for(let q = 0; q < arr.length; q++){
            if(Array.isArray(arr[i][q])){
                if(arr[i][q].length !== 1) return false;
                a[i][q] = arr[i][q][0];
            }else{
                a[i][q] = arr[i][q]
            }
        }
    }
    console.log(a);
    let k;
    /* строки */
    if(a.length === 9){
        k = [
            [0, 1, 2, 3, 4, 5, 6, 7, 8],
            [9, 10, 11, 12, 13, 14, 15, 16, 17],
            [18, 19, 20, 21, 22, 23, 24, 25, 26],
            [27, 28, 29, 30, 31, 32, 33, 34, 35],
            [36, 37, 38, 39, 40, 41, 42, 43, 44],
            [45, 46, 47, 48, 49, 50, 51, 52, 53],
            [54, 55, 56, 57, 58, 59, 60, 61, 62],
            [63, 64, 65, 66, 67, 68, 69, 70, 71],
            [72, 73, 74, 75, 76, 77, 78, 79, 80],
            /* блоки 3 х 3 */
            [0, 1, 2, 9, 10, 11, 18, 19, 20],
            [3, 4, 5, 12, 13, 14, 21, 22, 23],
            [6, 7, 8, 15, 16, 17, 24, 25, 26],
            [27, 28, 29, 36, 37, 38, 45, 46, 47],
            [30, 31, 32, 39, 40, 41, 48, 49, 50],
            [33, 34, 35, 42, 43, 44, 51, 52, 53],
            [54, 55, 56, 63, 64, 65, 72, 73, 74],
            [57, 58, 59, 66, 67, 68, 75, 76, 77],
            [60, 61, 62, 69, 70, 71, 78, 79, 80],
            /* столбцы */
            [0, 9, 18, 27, 36, 45, 54, 63, 72],
            [1, 10, 19, 28, 37, 46, 55, 64, 73],
            [2, 11, 20, 29, 38, 47, 56, 65, 74],
            [3, 12, 21, 30, 39, 48, 57, 66, 75],
            [4, 13, 22, 31, 40, 49, 58, 67, 76],
            [5, 14, 23, 32, 41, 50, 59, 68, 77],
            [6, 15, 24, 33, 42, 51, 60, 69, 78],
            [7, 16, 25, 34, 43, 52, 61, 70, 79],
            [8, 17, 26, 35, 44, 53, 62, 71, 80]
        ];
    }else if(a.length === 4){
        k = [
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [8, 9, 10, 11],
            [12, 13, 14, 15],
            [0, 1, 4, 5],
            [2, 3, 6, 7],
            [8, 9, 12, 13],
            [10, 11, 14, 15],
            [0, 4, 8, 12],
            [1, 5, 9, 13],
            [2, 6, 10, 14],
            [3, 7, 11, 15],
        ];
    }
    a = [].concat.apply([], a);
    return k.every(function(b) {
        var c = {};
        return b.every(function(b) {
            b = a[b];
            c[b] = (c[b] || 0) + 1;
            return 2 > c[b];
        });
    });

}
function addNull(n){
    if(n > 9) return n;
    return '0' + n;
}
function createSudoku(size) {
    function base(size) {
        let table = [];
        for(let i = 0; i < size * size; i++){
            table.push([]);
            for(let q = 0; q < size * size; q++){
                table[i][q] = Math.floor(((i*size + i/size + q) % (size*size) + 1));
            }
        }
        return table;
    }
    function transposing(size, table) {
        let arr = [];
        for(let i = 0; i < size * size; i++) arr.push([]);
        table.forEach((e)=>{
            e.forEach((b, index)=>{
                arr[index].push(b);
            });
        });
        return arr;
    }
    function swap_rows_small(size, table){
        let area = Math.floor(Math.random() * size);
        let line1 = Math.floor(Math.random() * size);

        let n1 = area * size + line1;
        let line2 = Math.floor(Math.random() * size);
        while (line1 === line2){
            line2 = Math.floor(Math.random() * size);
        }
        let n2 = area * size + line2;
        [table[n1], table[n2]] = [table[n2], table[n1]];
        return table;
    }
    function swap_colums_small(size, table){
        table = transposing(size, table);
        table = swap_rows_small(size, table);
        table = transposing(size, table);
        return table;
    }
    function swap_rows_area(size, table){
        let area1 = Math.floor(Math.random() * size);
        let area2 = Math.floor(Math.random() * size);
        while (area1 === area2){
            area2 = Math.floor(Math.random() * size);
        }
        for(let i = 0; i < size; i++){
            let N1 = area1*size + i,
                N2 = area2*size + i;
            [table[N1],table[N2]] = [table[N2], table[N1]]
        }
        return table;
    }
    function swap_colums_area(size, table){
        table = transposing(size, table);
        table = swap_rows_area(size, table);
        table = transposing(size, table);
        return table
    }
    function mix(n, size, table){
        for(let i = 0; i < n; i++){
            let rand = Math.floor(Math.random() * 5);
            if(rand === 0) table = transposing(size, table);
            if(rand === 1) table = swap_rows_small(size, table);
            if(rand === 2) table = swap_colums_small(size, table);
            if(rand === 3) table = swap_rows_area(size, table);
            if(rand === 4) table = swap_colums_area(size, table);
        }
        return table;
    }

    let table = base(size);
    return mix(10, size, table);
}